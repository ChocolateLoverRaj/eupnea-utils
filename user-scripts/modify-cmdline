#!/usr/bin/env python3

import argparse
import os
import sys

sys.path.insert(0, "/usr/lib/eupnea")
from functions import *


# parse arguments from the cli.
def process_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', '--print-current', action="store_true", dest="print_current", default=False,
                        help="Show current command line")
    parser.add_argument("--cmdline-path", dest="cmdline_path", default="/proc/cmdline",
                        help="Kernel flags to be used. Defaults to /proc/cmdline. Must be a full path. Disables "
                             "interactive mode.")
    parser.add_argument("-v", action="store_true", dest="verbose", default=False, help="Print more output")
    return parser.parse_args()


if __name__ == "__main__":
    args = process_args()
    if args.print_current:
        print_header("Current command line: ")
        with open("/proc/cmdline", "r") as file:
            print(file.read())
        exit(1)

    # Restart script as root
    if os.geteuid() != 0:
        sudo_args = ['sudo', sys.executable] + sys.argv + [os.environ]
        os.execlpe('sudo', *sudo_args)

    print_status("Reading partition table")
    partitions = bash("mount | grep ' / ' | cut -d' ' -f 1")
    partitions = partitions[:-1]  # get device name

    # Save current cmdline to a file
    print_status(f"Using cmdline from {args.cmdline_path}")
    with open(args.cmdline_path, "r") as file:
        current_cmdline = file.read().strip()
    with open("/tmp/cmdline", "w") as file:
        file.write(current_cmdline)

    # remove cros_secure kernel flags, as they are added automatically each boot anyways
    with open("/tmp/cmdline", "r") as file:
        tmp_cmdline = file.read().strip()
    tmp_cmdline = tmp_cmdline.replace("cros_secure ", "")
    with open("/tmp/cmdline", "w") as file:
        file.write(tmp_cmdline)

    if args.cmdline_path == "/proc/cmdline":
        # Prompt user to edit cmdline with a cli text editor
        # Default to nano, fallback to vim or vi
        # "bash" from functions.py doesn't work interactively -> use os.system
        if path_exists("/usr/bin/gedit"):
            os.system("gedit /tmp/cmdline")
        elif path_exists("/usr/bin/gnome-text-editor"):
            os.system("gnome-text-editor /tmp/cmdline")
        elif path_exists("/usr/bin/nano"):
            os.system("nano /tmp/cmdline")
        elif path_exists("/usr/bin/vim"):
            os.system("vim /tmp/cmdline")
        else:
            os.system("vi /tmp/cmdline")

    print_header("New cmdline:")
    with open("/tmp/cmdline", "r") as file:
        print(file.read())
    if args.cmdline_path == "/proc/cmdline":  # Ask user to confirm new cmdline
        input("\033[92m" + "Press ENTER to continue or CTRL+C to cancel" + "\033[0m")

    print_status("Backing up kernel")
    # Backup old kernel to part 2
    bash(f"dd if={partitions}1 of={partitions}2")  # backup kernel partition to second partition
    bash(f"dd if={partitions}1 of=/tmp/old_kernel")  # for futility
    print_status("Signing new kernel")
    bash("futility vbutil_kernel --repack /tmp/new_kernel --version 1 --keyblock " +
         "/usr/share/vboot/devkeys/kernel.keyblock --signprivate /usr/share/vboot/devkeys/kernel_data_key.vbprivk " +
         "--oldblob /tmp/old_kernel --config /tmp/cmdline")
    print_status("Flashing new kernel")
    bash(f"dd if=/tmp/new_kernel of={partitions}1")

    if args.cmdline_path == "/proc/cmdline":  # aka interactive mode
        print_header("Kernel cmdline modified successfully! Please reboot to use the new cmdline")
        input("\033[92m" + "Press ENTER to reboot or CTRL+C to cancel reboot" + "\033[0m")
        bash("reboot")
